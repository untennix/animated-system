# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-12-07 23:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: gitcli.7:10
#, no-wrap
msgid "GITCLI"
msgstr ""

#. type: TH
#: gitcli.7:10
#, no-wrap
msgid "11/29/2021"
msgstr ""

#. type: TH
#: gitcli.7:10
#, no-wrap
msgid "Git 2\\&.34\\&.1"
msgstr ""

#. type: TH
#: gitcli.7:10
#, no-wrap
msgid "Git Manual"
msgstr ""

#.  -----------------------------------------------------------------
#.  * MAIN CONTENT STARTS HERE *
#.  -----------------------------------------------------------------
#. type: SH
#: gitcli.7:30
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: gitcli.7:32
msgid "gitcli - Git command-line interface and conventions"
msgstr ""

#. type: SH
#: gitcli.7:32
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: gitcli.7:35
msgid "gitcli"
msgstr ""

#. type: SH
#: gitcli.7:35
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: gitcli.7:38
msgid "This manual describes the convention used throughout Git CLI\\&."
msgstr ""

#. type: Plain text
#: gitcli.7:40
msgid ""
"Many commands take revisions (most often \"commits\", but sometimes "
"\"tree-ish\", depending on the context and command) and paths as their "
"arguments\\&. Here are the rules:"
msgstr ""

#. type: Plain text
#: gitcli.7:59
msgid ""
"Revisions come first and then paths\\&. E\\&.g\\&. in B<git diff v1\\&.0 "
"v2\\&.0 arch/x86 include/asm-x86>, B<v1\\&.0> and B<v2\\&.0> are revisions "
"and B<arch/x86> and B<include/asm-x86> are paths\\&."
msgstr ""

#. type: Plain text
#: gitcli.7:76
msgid ""
"When an argument can be misunderstood as either a revision or a path, they "
"can be disambiguated by placing B<--> between them\\&. E\\&.g\\&.  B<git "
"diff -- HEAD> is, \"I have a file called HEAD in my work tree\\&. Please "
"show changes between the version I staged in the index and what I have in "
"the work tree for that file\", not \"show difference between the HEAD commit "
"and the work tree as a whole\"\\&. You can say B<git diff HEAD --> to ask "
"for the latter\\&."
msgstr ""

#. type: Plain text
#: gitcli.7:94
msgid ""
"Without disambiguating B<-->, Git makes a reasonable guess, but errors out "
"and asking you to disambiguate when ambiguous\\&. E\\&.g\\&. if you have a "
"file called HEAD in your work tree, B<git diff HEAD> is ambiguous, and you "
"have to say either B<git diff HEAD --> or B<git diff -- HEAD> to "
"disambiguate\\&."
msgstr ""

#. type: Plain text
#: gitcli.7:110
msgid ""
"Because B<--> disambiguates revisions and paths in some commands, it cannot "
"be used for those commands to separate options and revisions\\&. You can use "
"B<--end-of-options> for this (it also works for commands that do not "
"distinguish between revisions in paths, in which case it is simply an alias "
"for B<-->)\\&."
msgstr ""

#. type: Plain text
#: gitcli.7:114
msgid ""
"When writing a script that is expected to handle random user-input, it is a "
"good practice to make it explicit which arguments are which by placing "
"disambiguating B<--> at appropriate places\\&."
msgstr ""

#. type: Plain text
#: gitcli.7:125
msgid ""
"Many commands allow wildcards in paths, but you need to protect them from "
"getting globbed by the shell\\&. These two mean different things:"
msgstr ""

#. type: Plain text
#: gitcli.7:132
#, no-wrap
msgid ""
"$ git restore *\\&.c\n"
"$ git restore \\e*\\&.c\n"
msgstr ""

#. type: Plain text
#: gitcli.7:145
msgid ""
"The former lets your shell expand the fileglob, and you are asking the dot-C "
"files in your working tree to be overwritten with the version in the "
"index\\&. The latter passes the B<*\\&.c> to Git, and you are asking the "
"paths in the index that match the pattern to be checked out to your working "
"tree\\&. After running B<git add hello\\&.c; rm hello\\&.c>, you will I<not> "
"see B<hello\\&.c> in your working tree with the former, but with the latter "
"you will\\&."
msgstr ""

#. type: Plain text
#: gitcli.7:160
msgid ""
"Just as the filesystem I<\\&.> (period) refers to the current directory, "
"using a I<\\&.> as a repository name in Git (a dot-repository) is a relative "
"path and means your current repository\\&."
msgstr ""

#. type: Plain text
#: gitcli.7:163
msgid ""
"Here are the rules regarding the \"flags\" that you should follow when you "
"are scripting Git:"
msgstr ""

#. type: Plain text
#: gitcli.7:176
msgid ""
"it\\(cqs preferred to use the non-dashed form of Git commands, which means "
"that you should prefer B<git foo> to B<git-foo>\\&."
msgstr ""

#. type: Plain text
#: gitcli.7:190
msgid ""
"splitting short options to separate words (prefer B<git foo -a -b> to B<git "
"foo -ab>, the latter may not even work)\\&."
msgstr ""

#. type: Plain text
#: gitcli.7:213
msgid ""
"when a command-line option takes an argument, use the I<stuck> form\\&. In "
"other words, write B<git foo -oArg> instead of B<git foo -o Arg> for short "
"options, and B<git foo --long-opt=Arg> instead of B<git foo --long-opt Arg> "
"for long options\\&. An option that takes optional option-argument must be "
"written in the I<stuck> form\\&."
msgstr ""

#. type: Plain text
#: gitcli.7:229
msgid ""
"when you give a revision parameter to a command, make sure the parameter is "
"not ambiguous with a name of a file in the work tree\\&. E\\&.g\\&. do not "
"write B<git log -1 HEAD> but write B<git log -1 HEAD -->; the former will "
"not work if you happen to have a file called B<HEAD> in the work tree\\&."
msgstr ""

#. type: Plain text
#: gitcli.7:248
msgid ""
"many commands allow a long option B<--option> to be abbreviated only to "
"their unique prefix (e\\&.g\\&. if there is no other option whose name "
"begins with B<opt>, you may be able to spell B<--opt> to invoke the "
"B<--option> flag), but you should fully spell them out when writing your "
"scripts; later versions of Git may introduce a new option whose name shares "
"the same prefix, e\\&.g\\&.  B<--optimize>, to make a short prefix that used "
"to be unique no longer unique\\&."
msgstr ""

#. type: SH
#: gitcli.7:249
#, no-wrap
msgid "ENHANCED OPTION PARSER"
msgstr ""

#. type: Plain text
#: gitcli.7:252
msgid ""
"From the Git 1\\&.5\\&.4 series and further, many Git commands (not all of "
"them at the time of the writing though) come with an enhanced option "
"parser\\&."
msgstr ""

#. type: Plain text
#: gitcli.7:254
msgid "Here is a list of the facilities provided by this option parser\\&."
msgstr ""

#. type: SS
#: gitcli.7:254
#, no-wrap
msgid "Magic Options"
msgstr ""

#. type: Plain text
#: gitcli.7:257
msgid ""
"Commands which have the enhanced option parser activated all understand a "
"couple of magic command-line options:"
msgstr ""

#. type: Plain text
#: gitcli.7:259
msgid "-h"
msgstr ""

#. type: Plain text
#: gitcli.7:261
msgid "gives a pretty printed usage of the command\\&."
msgstr ""

#. type: Plain text
#: gitcli.7:269
#, no-wrap
msgid ""
"$ git describe -h\n"
"usage: git describe [E<lt>optionsE<gt>] E<lt>commit-ishE<gt>*\n"
"   or: git describe [E<lt>optionsE<gt>] --dirty\n"
msgstr ""

#. type: Plain text
#: gitcli.7:276
#, no-wrap
msgid ""
"    --contains            find the tag that comes after the commit\n"
"    --debug               debug search strategy on stderr\n"
"    --all                 use any ref\n"
"    --tags                use any tag, even unannotated\n"
"    --long                always use long format\n"
"    --abbrev[=E<lt>nE<gt>]        use E<lt>nE<gt> digits to display SHA-1s\n"
msgstr ""

#. type: Plain text
#: gitcli.7:286
msgid ""
"Note that some subcommand (e\\&.g\\&.  B<git grep>) may behave differently "
"when there are things on the command line other than B<-h>, but B<git subcmd "
"-h> without anything else on the command line is meant to consistently give "
"the usage\\&."
msgstr ""

#. type: Plain text
#: gitcli.7:289
msgid "--help-all"
msgstr ""

#. type: Plain text
#: gitcli.7:291
msgid ""
"Some Git commands take options that are only used for plumbing or that are "
"deprecated, and such options are hidden from the default usage\\&. This "
"option gives the full list of options\\&."
msgstr ""

#. type: SS
#: gitcli.7:292
#, no-wrap
msgid "Negating options"
msgstr ""

#. type: Plain text
#: gitcli.7:295
msgid ""
"Options with long option names can be negated by prefixing B<--no->\\&. For "
"example, B<git branch> has the option B<--track> which is I<on> by "
"default\\&. You can use B<--no-track> to override that behaviour\\&. The "
"same goes for B<--color> and B<--no-color>\\&."
msgstr ""

#. type: SS
#: gitcli.7:295
#, no-wrap
msgid "Aggregating short options"
msgstr ""

#. type: Plain text
#: gitcli.7:298
msgid ""
"Commands that support the enhanced option parser allow you to aggregate "
"short options\\&. This means that you can for example use B<git rm -rf> or "
"B<git clean -fdx>\\&."
msgstr ""

#. type: SS
#: gitcli.7:298
#, no-wrap
msgid "Abbreviating long options"
msgstr ""

#. type: Plain text
#: gitcli.7:301
msgid ""
"Commands that support the enhanced option parser accepts unique prefix of a "
"long option as if it is fully spelled out, but use this with a "
"caution\\&. For example, B<git commit --amen> behaves as if you typed B<git "
"commit --amend>, but that is true only until a later version of Git "
"introduces another option that shares the same prefix, e\\&.g\\&. B<git "
"commit --amenity> option\\&."
msgstr ""

#. type: SS
#: gitcli.7:301
#, no-wrap
msgid "Separating argument from the option"
msgstr ""

#. type: Plain text
#: gitcli.7:304
msgid ""
"You can write the mandatory option parameter to an option as a separate word "
"on the command line\\&. That means that all the following uses work:"
msgstr ""

#. type: Plain text
#: gitcli.7:313
#, no-wrap
msgid ""
"$ git foo --long-opt=Arg\n"
"$ git foo --long-opt Arg\n"
"$ git foo -oArg\n"
"$ git foo -o Arg\n"
msgstr ""

#. type: Plain text
#: gitcli.7:320
msgid ""
"However, this is B<NOT> allowed for switches with an optional value, where "
"the I<stuck> form must be used:"
msgstr ""

#. type: Plain text
#: gitcli.7:328
#, no-wrap
msgid ""
"$ git describe --abbrev HEAD     # correct\n"
"$ git describe --abbrev=10 HEAD  # correct\n"
"$ git describe --abbrev 10 HEAD  # NOT WHAT YOU MEANT\n"
msgstr ""

#. type: SH
#: gitcli.7:333
#, no-wrap
msgid "NOTES ON FREQUENTLY CONFUSED OPTIONS"
msgstr ""

#. type: Plain text
#: gitcli.7:336
msgid ""
"Many commands that can work on files in the working tree and/or in the index "
"can take B<--cached> and/or B<--index> options\\&. Sometimes people "
"incorrectly think that, because the index was originally called cache, these "
"two are synonyms\\&. They are B<not> \\(em these two options mean very "
"different things\\&."
msgstr ""

#. type: Plain text
#: gitcli.7:353
msgid ""
"The B<--cached> option is used to ask a command that usually works on files "
"in the working tree to B<only> work with the index\\&. For example, B<git "
"grep>, when used without a commit to specify from which commit to look for "
"strings in, usually works on files in the working tree, but with the "
"B<--cached> option, it looks for strings in the index\\&."
msgstr ""

#. type: Plain text
#: gitcli.7:372
msgid ""
"The B<--index> option is used to ask a command that usually works on files "
"in the working tree to B<also> affect the index\\&. For example, B<git stash "
"apply> usually merges changes recorded in a stash entry to the working tree, "
"but with the B<--index> option, it also merges changes to the index as "
"well\\&."
msgstr ""

#. type: Plain text
#: gitcli.7:375
msgid ""
"B<git apply> command can be used with B<--cached> and B<--index> (but not at "
"the same time)\\&. Usually the command only affects the files in the working "
"tree, but with B<--index>, it patches both the files and their index "
"entries, and with B<--cached>, it modifies only the index entries\\&."
msgstr ""

#. type: Plain text
#: gitcli.7:377
msgid ""
"See also "
"\\m[blue]B<https://lore\\&.kernel\\&.org/git/7v64clg5u9\\&.fsf@assigned-by-dhcp\\&.cox\\&.net/>\\m[] "
"and "
"\\m[blue]B<https://lore\\&.kernel\\&.org/git/7vy7ej9g38\\&.fsf@gitster\\&.siamese\\&.dyndns\\&.org/>\\m[] "
"for further information\\&."
msgstr ""

#. type: Plain text
#: gitcli.7:379
msgid ""
"Some other commands that also work on files in the working tree and/or in "
"the index can take B<--staged> and/or B<--worktree>\\&."
msgstr ""

#. type: Plain text
#: gitcli.7:391
msgid ""
"B<--staged> is exactly like B<--cached>, which is used to ask a command to "
"only work on the index, not the working tree\\&."
msgstr ""

#. type: Plain text
#: gitcli.7:403
msgid ""
"B<--worktree> is the opposite, to ask a command to work on the working tree "
"only, not the index\\&."
msgstr ""

#. type: Plain text
#: gitcli.7:414
msgid ""
"The two options can be specified together to ask a command to work on both "
"the index and the working tree\\&."
msgstr ""

#. type: SH
#: gitcli.7:415
#, no-wrap
msgid "GIT"
msgstr ""

#. type: Plain text
#: gitcli.7:417
msgid "Part of the B<git>(1) suite"
msgstr ""
